// src/features/schedule/hooks/useTimedScheduleData.ts
import { useEffect } from "react";
import { useQueryClient } from "@tanstack/react-query";
import { useTimedSchedule } from "./useTimedSchedule";
import { useChildPlaylist } from "../../../ReactQuery/schedule/useChildPlaylist";
import { prefetchNextPlaylist } from "../../../ReactQuery/schedule/prefetchNextPlaylist";
import { qk } from "../../../ReactQuery/queryKeys";
import { fetchDefaultPlaylist } from "../../../ReactQuery/schedule/useDefaultPlaylist";
import { useServerClockStrict } from "../../../utils/useServerClockStrict";

export const LS_SCREEN_ID = "screenId";

// ‚è±Ô∏è Prefetch thresholds (ÿ™ŸÇÿØÿ± ÿ™ÿπÿØŸëŸÑ ŸÖŸÜ ŸáŸàŸÜ)
const PREFETCH_NEXT_CHILD_MS = 5 * 60_000; // 5 ÿØŸÇÿßÿ¶ŸÇ ŸÇÿ®ŸÑ ÿ®ÿØÿßŸäÿ© ÿßŸÑŸÄ child ÿßŸÑŸÇÿßÿØŸÖ
const PREFETCH_DEFAULT_BEFORE_END_MS = 5 * 60_000; // 5 ÿØŸÇÿßÿ¶ŸÇ ŸÇÿ®ŸÑ ŸÜŸáÿßŸäÿ© ÿßŸÑŸÄ window ÿßŸÑÿ≠ÿßŸÑŸäÿ©

export function useTimedScheduleData() {
  const screenId =
    (typeof window !== "undefined" && localStorage.getItem(LS_SCREEN_ID)) ||
    undefined;

  const { parent, activeScheduleId, active, next } = useTimedSchedule(screenId);
  const child = useChildPlaylist(activeScheduleId, screenId);
  const qc = useQueryClient();
  const clock = useServerClockStrict();

  // Prefetch child ŸÑŸÑŸÄ next schedule ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿ≥ÿßÿπÿ© ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± (HH:mm:ss)
  useEffect(() => {
    if (!next) return;

    // ms ŸÑÿ∫ÿßŸäÿ© ÿ®ÿØÿßŸäÿ© next.start_time
    const rawMs = clock.msUntil(next.start_time);
    if (rawMs == null) return;

    // ÿ®ÿØŸÜÿß ŸÜÿ®ŸÑŸëÿ¥ prefetch ŸÇÿ®ŸÑ prefetchMs ŸÖŸÜ ÿ®ÿØÿßŸäÿ© ÿßŸÑŸÄ child
    const delay = Math.max(0, rawMs - PREFETCH_NEXT_CHILD_MS);

    let timer: number | undefined;
    const arm = () => {
      prefetchNextPlaylist(qc, next.scheduleId, screenId).catch(() => {});
    };

    if (delay === 0) {
      arm();
    } else {
      timer = window.setTimeout(arm, delay);
    }

    return () => {
      if (timer) clearTimeout(timer);
    };
  }, [next?.scheduleId, next?.start_time, screenId, qc, clock]);

  // Prefetch ŸÑŸÑŸÄ DEFAULT playlist ŸÇÿ®ŸÑ ŸÜŸáÿßŸäÿ© window ÿßŸÑÿ≠ÿßŸÑŸäÿ© (active) ÿ≠ÿ≥ÿ® ÿ≥ÿßÿπÿ© ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±
  useEffect(() => {
    if (!active || !screenId) return;

    const rawMs = clock.msUntil(active.end_time);
    if (rawMs == null) return;

    const delay = Math.max(0, rawMs - PREFETCH_DEFAULT_BEFORE_END_MS);

    let timer: number | undefined;
    const arm = () => {
      qc.prefetchQuery({
        queryKey: qk.def(screenId),
        queryFn: () => fetchDefaultPlaylist(screenId),
        staleTime: 5 * 60_000,
      }).catch(() => {});
    };

    if (delay === 0) {
      arm();
    } else {
      timer = window.setTimeout(arm, delay);
    }

    return () => {
      if (timer) clearTimeout(timer);
    };
  }, [active?.scheduleId, active?.end_time, screenId, qc, clock]);

  return {
    screenId,
    parent,
    activeScheduleId,
    active,
    next,
    child,
    isLoading: parent.isLoading || child.isLoading,
    isError: parent.isError || child.isError,
  };
}  // src/features/schedule/hooks/useTimedSchedule.ts
import { useEffect, useMemo, useRef, useState } from "react";
import { useParentSchedules } from "../../../ReactQuery/schedule/useParentSchedules";
import type { ParentScheduleItem } from "../../../types/schedule";
import { pickScheduleId } from "../../../ReactQuery/schedule/useParentSchedules";
import { useServerClockStrict } from "../../../utils/useServerClockStrict";
import {
  resolveActiveAndNext,
  isInactiveSchedule,   // ‚úÖ import helper
} from "../../../utils/scheduleTime";

/** ÿ≠ÿ≥ÿßÿ® ms ÿ≠ÿ™Ÿâ ÿ£ŸàŸÑ boundary (start ÿ£Ÿà end) ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿ≥ÿßÿπÿ© ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± */
function nextBoundaryDelayMsServer(
  items: ParentScheduleItem[],
  clock: ReturnType<typeof useServerClockStrict>
): number | null {
  if (!items.length) return null;

  const candidates: number[] = [];

  for (const it of items) {
    if (isInactiveSchedule((it as any).status)) continue; // ‚úÖ ÿ™ÿ¨ÿßŸáŸÑ inactive ŸÅÿπŸÑÿßŸã

    const startMs = clock.msUntil(it.start_time);
    if (startMs != null && startMs > 0) candidates.push(startMs);

    const endMs = clock.msUntil(it.end_time);
    if (endMs != null && endMs > 0) candidates.push(endMs);
  }

  if (!candidates.length) return null;
  return Math.min(...candidates); // ÿ£ŸÇÿ±ÿ® boundary
}

export function useTimedSchedule(screenId?: string) {
  const parent = useParentSchedules(screenId);
  const clock = useServerClockStrict();

  const day = parent.data?.date;
  const items: ParentScheduleItem[] = parent.data?.data ?? [];

  const [activeScheduleId, setActiveScheduleId] = useState<number | undefined>(
    undefined
  );

  const nowSec = clock.nowSecs();

  const computed = useMemo(() => {
    if (!day) {
      return {
        active: undefined as ParentScheduleItem | undefined,
        next: null as ParentScheduleItem | null,
      };
    }
    return resolveActiveAndNext(items, nowSec);
  }, [day, items, nowSec]);

  useEffect(() => {
    setActiveScheduleId(pickScheduleId(computed.active) ?? undefined);
  }, [computed.active]);

  useEffect(() => {
    if (!day) return;
    // eslint-disable-next-line no-console
    console.log("[SCHEDULE_DEBUG] useTimedSchedule", {
      day,
      nowSec,
      items: items.map((it) => ({
        scheduleId: pickScheduleId(it),
        status: (it as any).status,
        start: it.start_time,
        end: it.end_time,
      })),
      activeScheduleId: pickScheduleId(computed.active),
      nextScheduleId: pickScheduleId(computed.next),
    });
  }, [day, items, nowSec, computed.active, computed.next]);

  const timerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  useEffect(() => {
    if (!day || items.length === 0) return;

    if (timerRef.current) {
      clearTimeout(timerRef.current);
      timerRef.current = null;
    }

    const delay = nextBoundaryDelayMsServer(items, clock);
    if (delay == null) return;

    const fireDelay = Math.max(0, delay + 50);

    timerRef.current = setTimeout(() => {
      const nowAfter = clock.nowSecs();
      const { active } = resolveActiveAndNext(items, nowAfter);
      setActiveScheduleId(pickScheduleId(active) ?? undefined);
      parent.refetch();
    }, fireDelay);

    return () => {
      if (timerRef.current) clearTimeout(timerRef.current);
    };
  }, [day, items, parent, clock]);

  // Safety guard: check ŸÉŸÑ 10 ÿ´ŸàÿßŸÜŸä ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿ≥ÿßÿπÿ© ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±
  useEffect(() => {
    const id = setInterval(() => {
      if (!day) return;
      const now = clock.nowSecs();
      const { active } = resolveActiveAndNext(items, now);
      const newId = pickScheduleId(active) ?? undefined;
      if (newId !== activeScheduleId) {
        setActiveScheduleId(newId);
      }
    }, 10_000);
    return () => clearInterval(id);
  }, [day, items, activeScheduleId, clock]);

  return {
    parent,
    activeScheduleId,
    active: computed.active,
    next: computed.next,
  };
}  // src/features/schedule/hooks/useTimedScheduleData.ts
import { useEffect } from "react";
import { useQueryClient } from "@tanstack/react-query";
import { useTimedSchedule } from "./useTimedSchedule";
import { useChildPlaylist } from "../../../ReactQuery/schedule/useChildPlaylist";
import { prefetchNextPlaylist } from "../../../ReactQuery/schedule/prefetchNextPlaylist";
import type { ParentScheduleItem } from "../../../types/schedule";
import { qk } from "../../../ReactQuery/queryKeys";
import { fetchDefaultPlaylist } from "../../../ReactQuery/schedule/useDefaultPlaylist";

export const LS_SCREEN_ID = "screenId";

// ‚è±Ô∏è Prefetch thresholds (tweak here: 3 or 5 minutes)
const PREFETCH_NEXT_CHILD_MS = 5 * 60_000; // 5 min before next schedule starts
const PREFETCH_DEFAULT_BEFORE_END_MS = 5 * 60_000; // 5 min before current window ends

function timeToStartMs(
  item: ParentScheduleItem,
  dayDate: string,
  now = new Date()
) {
  const t = new Date(`${dayDate}T${item.start_time}`).getTime();
  return t - now.getTime();
}

function timeToEndMs(
  item: ParentScheduleItem,
  dayDate: string,
  now = new Date()
) {
  const t = new Date(`${dayDate}T${item.end_time}`).getTime();
  return t - now.getTime();
}

export function useTimedScheduleData() {
  const screenId =
    (typeof window !== "undefined" && localStorage.getItem(LS_SCREEN_ID)) ||
    undefined;

  const { parent, activeScheduleId, active, next } = useTimedSchedule(screenId);
  const child = useChildPlaylist(activeScheduleId, screenId);
  const qc = useQueryClient();

  // Prefetch the NEXT schedule's child playlist ahead of time (5 minutes)
  useEffect(() => {
    if (!next || !parent.data?.date) return;

    const ms = timeToStartMs(next, parent.data.date, new Date());
    const delay = Math.max(0, ms - PREFETCH_NEXT_CHILD_MS);

    let timer: number | undefined;
    const arm = () => {
      prefetchNextPlaylist(qc, next.scheduleId, screenId).catch(() => {});
    };

    if (delay === 0) {
      arm();
    } else {
      timer = window.setTimeout(arm, delay);
    }

    return () => {
      if (timer) clearTimeout(timer);
    };
  }, [next?.scheduleId, parent.data?.date, screenId, qc, next]);

  // Prefetch the DEFAULT playlist shortly before the current window ends (5 minutes).
  // This ensures when we hit a gap, default is ready and shows instantly.
  useEffect(() => {
    if (!active || !parent.data?.date || !screenId) return;

    const ms = timeToEndMs(active, parent.data.date, new Date());
    const delay = Math.max(0, ms - PREFETCH_DEFAULT_BEFORE_END_MS);

    let timer: number | undefined;
    const arm = () => {
      qc.prefetchQuery({
        queryKey: qk.def(screenId),
        queryFn: () => fetchDefaultPlaylist(screenId),
        staleTime: 5 * 60_000,
      }).catch(() => {});
    };

    if (delay === 0) {
      arm();
    } else {
      timer = window.setTimeout(arm, delay);
    }

    return () => {
      if (timer) clearTimeout(timer);
    };
  }, [active?.scheduleId, parent.data?.date, screenId, qc, active]);

  return {
    screenId,
    parent,
    activeScheduleId,
    active,
    next,
    child,
    isLoading: parent.isLoading || child.isLoading,
    isError: parent.isError || child.isError,
  };
}  // src/features/schedule/hooks/useResolvedPlaylist.ts
import { useEffect, useMemo } from "react";
import { useQueryClient } from "@tanstack/react-query";
import { useTimedSchedule } from "./useTimedSchedule";
import {
  useChildPlaylist,
  fetchChildPlaylist,
} from "../../../ReactQuery/schedule/useChildPlaylist";
import {
  useDefaultPlaylist,
  fetchDefaultPlaylist,
} from "../../../ReactQuery/schedule/useDefaultPlaylist";
import {
  saveLastGoodDefault,
  loadLastGoodChild,
  loadLastGoodDefault,
  getNowPlaying,
} from "../../../utils/playlistCache";
import { prefetchWindow } from "../../../utils/mediaPrefetcher";
import { qk } from "../../../ReactQuery/queryKeys";
import { useServerClockStrict } from "../../../utils/useServerClockStrict";

type Decision =
  | { source: "child"; playlist: any; reason: string }
  | { source: "default"; playlist: any; reason: string }
  | { source: "cache"; playlist: any; reason: string }
  | { source: "empty"; playlist: null; reason: string };

const hasSlides = (pl?: any) => Array.isArray(pl?.slides) && pl.slides.length > 0;

/* ---------- Safe access helpers ---------- */
function pickStr(obj: unknown, key: string): string | undefined {
  const v = (obj as any)?.[key];
  return typeof v === "string" ? v : undefined;
}
function pickFirstDefined<T = any>(obj: unknown, keys: string[]): T | undefined {
  for (const k of keys) {
    const v = (obj as any)?.[k];
    if (v !== undefined && v !== null) return v as T;
  }
  return undefined;
}

export function useResolvedPlaylist(screenId?: string) {
  const qc = useQueryClient();
  const clock = useServerClockStrict();

  const { parent, activeScheduleId, active, next } = useTimedSchedule(screenId);

  /* ‚îÄ‚îÄ Live queries ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  const child = useChildPlaylist(activeScheduleId, screenId);

  // ‚úÖ ŸÖŸáŸÖ: ŸÜŸÇÿ±ÿ± ÿßŸÑŸÄ default ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ Ÿàÿ¨ŸàÿØ active ŸÜŸÅÿ≥Ÿáÿå ŸÖÿ¥ ÿßŸÑŸÄ ID
  const wantDefault =
    !active || child.isError || !hasSlides(child.data?.playlist);

  const defaultQ = useDefaultPlaylist(screenId, wantDefault as any);

  /* ‚îÄ‚îÄ Persist ÿ¢ÿÆÿ± ŸÜÿ≥ÿÆÿ© ŸÜÿßÿ¨ÿ≠ÿ© ŸÑŸÑŸÄ Default ŸÅŸÇÿ∑ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  useEffect(() => {
    if (hasSlides(defaultQ.data?.playlist)) {
      saveLastGoodDefault(defaultQ.data!.playlist);
    }
  }, [defaultQ.data?.playlist]);

  /* ‚îÄ‚îÄ Prefetch default ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑŸÅÿ¨Ÿàÿßÿ™ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  useEffect(() => {
    if (!screenId) return;
    if (!active) {
      qc
        .prefetchQuery({
          queryKey: qk.def(screenId),
          queryFn: () => fetchDefaultPlaylist(screenId),
          staleTime: 5 * 60_000,
        })
        .catch(() => {});
    }
  }, [screenId, active, qc]);

  /* ‚îÄ‚îÄ Prefetch child ÿπŸÜÿØ ÿ™ÿ∫ŸäŸëÿ± ÿßŸÑŸÄschedule ÿßŸÑŸÅÿπŸëÿßŸÑ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  useEffect(() => {
    if (!activeScheduleId) return;
    qc
      .prefetchQuery({
        queryKey: qk.child(activeScheduleId, screenId),
        queryFn: () => fetchChildPlaylist(activeScheduleId, screenId),
        staleTime: 0,
      })
      .catch(() => {});
  }, [activeScheduleId, screenId, qc]);

  /* ‚îÄ‚îÄ ÿ™ÿ£ÿÆŸäÿ±ÿßÿ™ ŸÖÿ®ŸÜŸäÿ© ÿπŸÑŸâ ÿ≥ÿßÿπÿ© ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± ŸÅŸÇÿ∑ (ŸÑŸÄ prewarm/debug) ‚îÄ‚îÄ */
  const activeEndDelayMs = useMemo(() => {
    const endTime = pickStr(active, "end_time"); // HH:mm:ss
    return endTime ? clock.msUntil(endTime) : undefined;
  }, [active, clock]);

  const nextStartDelayMs = useMemo(() => {
    const startTime = pickStr(next, "start_time"); // HH:mm:ss
    return startTime ? clock.msUntil(startTime) : undefined;
  }, [next, clock]);

  const upcomingPlaylist = useMemo(() => {
    return pickFirstDefined<any>(next, ["playlist", "child"]) ?? null;
  }, [next]);

  /* ‚îÄ‚îÄ Decision logic: ŸÜÿ´ŸÇ ÿ®ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±/Reverb ÿπŸÜÿØ Ÿàÿ¨ŸàÿØ schedule ‚îÄ‚îÄ */
  const decision: Decision = useMemo(() => {
    const running = getNowPlaying() ?? null;

    const cachedChild = loadLastGoodChild();
    const cachedDefault = loadLastGoodDefault();

    const liveChild = child.data?.playlist;
    const liveDefault = defaultQ.data?.playlist;

    // ‚úÖ ÿßŸÑÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿ≠ŸÇŸäŸÇŸä ŸÑŸàÿ¨ŸàÿØ schedule ŸÅÿπŸëÿßŸÑ
    const hasActiveSchedule = !!active;

    /* (A) ŸÑÿß ŸäŸàÿ¨ÿØ schedule ÿ≠ÿßŸÑŸäÿßŸã ‚Üí ŸÜÿ±ÿ¨Ÿëÿ≠ ÿßŸÑŸÄ Default ÿØÿßÿ¶ŸÖÿßŸã */
    if (!hasActiveSchedule) {
      // 1) ÿ£ÿ≠ÿØÿ´ Default ŸÖŸÜ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±
      if (hasSlides(liveDefault)) {
        return {
          source: "default",
          playlist: liveDefault,
          reason: "no schedule ‚Üí fresh default",
        };
      }
      // 2) Default ŸÖŸÜ ÿßŸÑŸÉÿßÿ¥
      if (hasSlides(cachedDefault?.playlist)) {
        return {
          source: "cache",
          playlist: cachedDefault!.playlist,
          reason: "no schedule ‚Üí cached default",
        };
      }
      // 3) ŸÑŸà ÿßŸÑŸÄrunning ÿßŸÑÿ≠ÿßŸÑŸä ŸÉÿßŸÜ Defaultÿå ÿÆŸÑŸäŸá (ÿ±ŸäŸÅÿ±Ÿäÿ¥ ÿ£Ÿà ÿ±ÿ¨Ÿàÿπ ŸÖŸÜ ÿ£ŸàŸÅŸÑÿßŸäŸÜ)
      if (
        running &&
        hasSlides(running.playlist) &&
        running.source === "default"
      ) {
        return {
          source: "cache",
          playlist: running.playlist,
          reason: "no schedule ‚Üí keep running default",
        };
      }
      // 4) ŸÑÿß ÿ¥Ÿäÿ°
      return {
        source: "empty",
        playlist: null,
        reason: "no schedule ‚Üí no default available",
      };
    }

    /* (B) ŸäŸàÿ¨ÿØ schedule (ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± ŸáŸà ÿßŸÑŸÑŸä ŸÇÿ±ÿ±) */
    // ÿ£ŸàŸÑŸàŸäÿ©: Child ŸÖŸÜ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±
    if (hasSlides(liveChild)) {
      return {
        source: "child",
        playlist: liveChild,
        reason: "active schedule ‚Üí live child",
      };
    }

    // ÿ´ŸÖ Child ŸÖŸÜ ÿßŸÑŸÉÿßÿ¥ (ŸÖÿ±Ÿëÿ™ playlist ŸÑŸÅÿ© ŸÉÿßŸÖŸÑÿ© ÿ≥ÿßÿ®ŸÇÿßŸã)
    if (hasSlides(cachedChild?.playlist)) {
      return {
        source: "cache",
        playlist: cachedChild!.playlist,
        reason: "active schedule ‚Üí cached child",
      };
    }

    // Fallback: Default (live ÿ´ŸÖ cached)
    if (hasSlides(liveDefault)) {
      return {
        source: "default",
        playlist: liveDefault,
        reason: "active schedule ‚Üí fallback default (live)",
      };
    }
    if (hasSlides(cachedDefault?.playlist)) {
      return {
        source: "cache",
        playlist: cachedDefault!.playlist,
        reason: "active schedule ‚Üí fallback default (cached)",
      };
    }

    // ÿ¢ÿÆÿ± ŸÖÿ≠ÿßŸàŸÑÿ©: ŸÑŸà ŸÅŸä running playlist ÿÆŸÑŸëŸäŸá
    if (running && hasSlides(running.playlist)) {
      return {
        source: "cache",
        playlist: running.playlist,
        reason: "active schedule ‚Üí keep running playlist",
      };
    }

    // ŸÑÿß ÿ¥Ÿäÿ° ŸÖÿ™ÿßÿ≠ ÿ±ÿ∫ŸÖ Ÿàÿ¨ŸàÿØ schedule
    return {
      source: "empty",
      playlist: null,
      reason: "active schedule ‚Üí nothing available",
    };
  }, [
    active,
    child.data?.playlist,
    defaultQ.data?.playlist,
  ]);

  /* ‚îÄ‚îÄ Prefetch ŸÜÿßŸÅÿ∞ÿ© ŸÖÿ®ŸÉŸëÿ±ÿ© ŸÖŸÜ ÿßŸÑŸÇÿ±ÿßÿ± ÿßŸÑÿ≠ÿßŸÑŸä ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  useEffect(() => {
    if (!hasSlides(decision.playlist)) return;
    const cancel = prefetchWindow(decision.playlist.slides, 0, 2);
    return () => cancel();
  }, [decision.playlist]);

  /* ‚îÄ‚îÄ Quiet refresh helper ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  const quietRefreshAll = async (overrideScheduleId?: number | string | null) => {
    const sid = overrideScheduleId ?? activeScheduleId ?? undefined;
    const parentKey = qk.parent(screenId);
    const childKey = sid != null ? qk.child(sid, screenId) : null;
    const defaultKey = qk.def(screenId);

    await qc.invalidateQueries({ queryKey: parentKey, refetchType: "active" });
    if (childKey)
      await qc.invalidateQueries({ queryKey: childKey, refetchType: "active" });
    await qc.invalidateQueries({ queryKey: defaultKey, refetchType: "active" });

    await qc.refetchQueries({ queryKey: parentKey, type: "active" });
    if (childKey)
      await qc.refetchQueries({ queryKey: childKey, type: "active" });
    await qc.refetchQueries({ queryKey: defaultKey, type: "active" });
  };

  // isLoading ŸÖÿß ŸÑÿßÿ≤ŸÖ Ÿäÿ∑ŸÅŸä ÿßŸÑÿ¥ÿßÿ¥ÿ© ÿ•ÿ∞ÿß ŸÖÿπŸÜÿß Playlist ÿ¨ÿßŸáÿ≤ÿ© ŸÑŸÑÿπÿ±ÿ∂
  const anyLoading = parent.isLoading || child.isLoading || defaultQ.isLoading;
  const isLoadingSafe = anyLoading && !hasSlides(decision.playlist);

  return {
    parent,
    active,
    next,
    activeScheduleId,
    decision,
    isLoading: isLoadingSafe,
    isError: parent.isError && child.isError && defaultQ.isError,
    quietRefreshAll,
    activeEndDelayMs,
    nextStartDelayMs,
    upcomingPlaylist,
  };
}  // src/utils/scheduleTime.ts
import type { ParentScheduleItem } from "../types/schedule";

/* HH:mm:ss ‚Üí seconds of day (0‚Äì86399) */
export function toSecs(hms?: string | null) {
  const [h = "0", m = "0", s = "0"] = String(hms ?? "").split(":");
  const hh = Math.max(0, Math.min(23, parseInt(h) || 0));
  const mm = Math.max(0, Math.min(59, parseInt(m) || 0));
  const ss = Math.max(0, Math.min(59, parseInt(s) || 0));
  return hh * 3600 + mm * 60 + ss;
}

/** Normalize status ‚Üí inactive or not */
export function isInactiveSchedule(rawStatus: any): boolean {
  const s = String(rawStatus ?? "active").toLowerCase().trim();
  // üîß tweak these if your backend uses other values
  if (s === "inactive" || s === "0" || s === "false") return true;
  return false;
}

/** Does this schedule cover nowSec, including cross-midnight windows? */
export function isScheduleActiveAt(
  item: ParentScheduleItem,
  nowSec: number
): boolean {
  const start = toSecs(item.start_time);
  const end = toSecs(item.end_time);
  const inactive = isInactiveSchedule((item as any).status);

  if (inactive) return false;

  const crossesMidnight = end < start;

  if (crossesMidnight) {
    // Example: 20:00 ‚Üí 02:00
    // Active if now >= 20:00 OR now < 02:00
    return nowSec >= start || nowSec < end;
  }

  // Normal same-day window
  return nowSec >= start && nowSec < end;
}

/** Compute active + next based on server seconds-of-day */
export function resolveActiveAndNext(
  items: ParentScheduleItem[],
  nowSec: number
): { active: ParentScheduleItem | undefined; next: ParentScheduleItem | null } {
  if (!items.length) return { active: undefined, next: null };

  const sorted = [...items].sort(
    (a, b) => toSecs(a.start_time) - toSecs(b.start_time)
  );

  let active: ParentScheduleItem | undefined;
  let next: ParentScheduleItem | null = null;

  for (const it of sorted) {
    const start = toSecs(it.start_time);
    const inactive = isInactiveSchedule((it as any).status);

    // Active right now?
    if (isScheduleActiveAt(it, nowSec)) {
      active = it;
      continue;
    }

    // First future window after now = next
    if (!inactive && start > nowSec && next == null) {
      next = it;
    }
  }

  return { active, next };
}  we have a bug in the active schedule and display in the time 